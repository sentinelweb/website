<p>
    During lockdown, I have been working on a little <a href="https://github.com/sentinelweb/cuer">app</a> for video
    content
    to hone my Android skills - I used the app to compare different UI architectures (MVP, MVVM and MVI). The MVI
    pattern is the latest architecture in vouge.
</p>
<h4>MVI Kotlin</h4>
<p>
    Since I had recently converted the app to use <a href="https://kotlinlang.org/docs/mpp-intro.html">Kotlin
    Multiplatform</a>
    it made sense that anything new should be available to all platforms and a great library for this is <a
        href="https://arkivanov.github.io/MVIKotlin/">MVIKotlin</a>.
    It is available for all platforms and is a fully featured MVI library - my experience with it was good. üëç
</p>
<p>If you would rather just skip to the code - it's
    <a href="https://github.com/sentinelweb/cuer/tree/develop/shared/src/commonMain/kotlin/uk/co/sentinelweb/cuer/app/ui/player">here</a>
</p>
<h5>Setup</h5>
<p>
    Since I am using coroutines in the project I use the coroutines library - it also works with RX Java. But since this
    is a multiplatform project then coroutines are the right way to go. The gradle setup is:
<pre>
<code style="language-kotlin">val ver_mvikotlin = 2.0.4 // defined in project properties
val commonMain by getting {
    dependencies {
        implementation("com.arkivanov.mvikotlin:mvikotlin:$ver_mvikotlin")
        implementation("com.arkivanov.mvikotlin:mvikotlin-main:$ver_mvikotlin")
        implementation("com.arkivanov.mvikotlin:mvikotlin-extensions-coroutines:$ver_mvikotlin")
    }
}
</code></pre>
</p>
<h5>Intents &amp; Labels</h5>
<p>
    I had to build a local video player so this has quite a lot of event based interactions to take care of, since the
    video player is an android view this will be generating all sorts of video playback events as things like playstate
    and video changes. These will all be feed into the MVI State as Intents. MVI kotlin output both State and Labels
    (side-effects).
    Since the video player internally has it own state it makes sense for the MVI to output Labels to the view whic can
    be use to
    control the actual video player view.
</p>
<p>
    There are also external events the the MVI needs to react to - such as track & playlist change events from the
    queue.
</p>
<p>
    MVIKotlin documentation suggests to make a controller to interact with the MVI this can be used to bind the MVI to
    the Intent sources (kotlin Flows) and also to connect the flows according to the view lifecycle.
<pre><code style="language-kotlin">import com.arkivanov.mvikotlin.extensions.coroutines.*

@ExperimentalCoroutinesApi
fun onViewCreated(views: List<PlayerContract.View>, viewLifecycle: Lifecycle) {
    if (binder != null) throw IllegalStateException("Already bound")
    binder = bind(viewLifecycle, BinderLifecycleMode.START_STOP) {
        views.forEach { view ->
        // store -> view
        store.states.mapNotNull { modelMapper.map(it) } bindTo view
        store.labels bindTo { label -> view.processLabel(label) }

        // view -> store
        view.events.mapNotNull(eventToIntent) bindTo store
    }
    // queue -> store
    queueConsumer.currentItemFlow.filterNotNull().mapNotNull { trackChangeToIntent(it) } bindTo store
    queueConsumer.currentPlaylistFlow.filterNotNull().mapNotNull { playlistChangeToIntent(it) } bindTo store
    playControls.intentFlow bindTo store // external player controls
    }
}
</code></pre>
This is a great advantage of the MVI pattern as it is transactional many event sources can be bound to the store.
</p>
<h4>Contract, Store and View</h4>
<p>
    I chose to make a <code>Contract</code> interface where the all definitions for the <code>Store</code> (<code>Intents</code>,
    <code>Labels</code> and <code>State</code>) which
    is the controlling side - also make the definition for the <code>View</code> here which reacts to the
    <code>Model</code>
    and defines <code>Events</code> - which are mapped to <code>Intents</code>. So we have
    <code>interface View : MviView&lt;View.Model, View.Event&gt;</code> - which also defines a
    <code>fun processLabel</code> which is used by the binder above.
</p><p>
    I like <code>Contract</code>'s because they keep all the
    definitions together. You can find it <a
        href="https://github.com/sentinelweb/cuer/blob/develop/shared/src/commonMain/kotlin/uk/co/sentinelweb/cuer/app/ui/player/PlayerContract.kt">here</a>.
</p>
<h4>Executing &amp; Reducing</h4>
<p>MVIKotlin has few objects:
<ul>
    <li><code>Bootstrapper</code>: Performs <code>Actions</code> on startup to produce <code>Results</code>.</li>
    <li><code>Executor</code>: Executes <code>Intent</code> to produce <code>Results</code></li>
    <li><code>Reducer</code>: Reduces <code>Results</code> into the <code>State</code></li>
</ul>
The
<code>Executor</code> is where operations take place. For a player it updates some external objects. Here is an example for a
track change:
<pre><code style="language-kotlin">private fun trackChange(intent: Intent.TrackChange) {
    intent.item.media.duration?.apply { skip.duration = this }
    livePlaybackController.clear(intent.item.media.platformId)
    // updates the track to the State
    dispatch(Result.SetVideo(intent.item, queueConsumer.playlist))
    // publishes a Label (tells the video view to load the video)
    publish(Label.Command(Load(intent.item.media.platformId, intent.item.media.positon ?: 0)))
    // updates the android media session
    mediaSessionManager.setMedia(intent.item.media, queueConsumer.playlist)
}
</code></pre>
</p>
<h4>View</h4>
<p>
    The final part is to connect up the View to the MVI controller - there are actually a few different views that use
    the same controler. Because
    there is a well defined interface the view just fires <code>Events</code> and reacts to changes in the
    <code>Model</code> and
    <code>Labels</code>.
</p>
<p>
    The easiest way was to define an inner class :
</p>
<p>
    <code>inner class MviViewImpl(playerView: YouTubePlayerView) : BaseMviView&lt;Model, Event&gt;(),
        PlayerContract.View</code>
</p>
<p>
    Another nice feature is the ability to diff the <code>Model</code> which saves excesive UI updates.
<pre><code style="language-kotlin">override val renderer: ViewRenderer<Model> = diff {
    diff(get = Model::description, set = {
        binding.portraitPlayerDescription.setModel(it)
    })
    diff(get = Model::screen, set = {
        when (it) {
            DESCRIPTION -> {
                binding.portraitPlayerDescription.isVisible = true
                binding.portraitPlayerPlaylist.isVisible = false
            }
            PLAYLIST -> {
                binding.portraitPlayerDescription.isVisible = false
                binding.portraitPlayerPlaylist.isVisible = true
            }
        }
    })
}
</code></pre>
Since the description is long (and contains HTML) we only want to update it when it changes not when other
<code>Model</code> fields change.
</p>
<p>
    Similarly for <code>Labels</code>. We can react to them cleanly.
<pre><code>override suspend fun processLabel(label: PlayerContract.MviStore.Label) {
when (label) {
is Command -> label.command.let { command ->
    when (command) {
        is Load -> player?.loadVideo(command.platformId, command.startPosition / 1000f)
        is Play -> player?.play()
        is Pause -> player?.pause()
        is SkipBack -> player?.seekTo(lastPositionSec - command.ms / 1000f)
        is SkipFwd -> player?.seekTo(lastPositionSec + command.ms / 1000f)
        is SeekTo -> {
            player?.seekTo(command.ms.toFloat() / 1000f)
        }
    }
}
</code></pre>
</p>
<h4>Conclusion</h4>
<p>I was pleased with the final result. I have an MVI that i can use cross-platform and write a web, iOS or desktop player View
    that should behave consistently across platforms. The <a href="https://arkivanov.github.io/MVIKotlin/">MVIKotlin</a>
    library is well thought out and written and I can recommend it.</p>